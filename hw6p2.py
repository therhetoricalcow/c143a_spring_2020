# -*- coding: utf-8 -*-
"""hw6p2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gyXx9AeQiuikbP19PDrYDWZAvJY8rzwA

## Homework 6, Problem 2 on population vector and optimal linear estimator

ECE C143A/C243A, Spring Quarter 2020, Prof. J.C. Kao, TAs J. Lee and T. Monsoor

Total: 30 points.  In this notebook, you will implement an optimal linear estimator decoder.
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import scipy.special
import scipy.io as sio
import math
import nsp as nsp
import pdb
# Load matplotlib images inline
# %matplotlib inline
# Reloading any code written in external .py files.
# %load_ext autoreload
# %autoreload 2
data = sio.loadmat('JR_2015-12-04_truncated2.mat') # load the .mat file.
R = data['R'][0,:]

"""### (a) (4 points) Tuning curve for one neuron

Fit a cosine tuning curve for electrode 17. On the same plot, plot the average firing rate for electrode 17 to each of the 8 directions and the fitted tuning curve.  The average firing rate should be computed in a window from [250, 500] ms after trial onset. Reach angle should be on the x-axis and firing rate on the y-axis. 

Hint: You may reuse code from HW #2 about tuning curve fitting to do this question.  We have provided two functions: calculateFR() and tuning() which ought simplify this question.  Take a look at what they do before calling them.  The function tuning returns the tuning curve of a neuron (i.e., the parameters of the tuning curve $c_0$, $c_1$, $\theta_0$ such that $f(\theta)= c_0+c_1 cos(\theta-\theta_0)$
"""

def calculateFR(i, neuron_idx=16, window=[250,500]):
    # Calculates the firing rate of neuron_idx on trial i in the given window range.
    # Output units are spikes/s
    return float(len(R[i]['spikeRaster'][neuron_idx,window[0]:window[1]].todense().nonzero()[1])) / (window[1] - window[0]) * 1000

def tuning(thetas, meanFRs):
    # Calculates the parameters of a tuning curve.
    F = np.concatenate((np.ones((np.size(thetas), 1)),np.matrix(np.sin(thetas)).T,np.matrix(np.cos(thetas)).T),axis = 1)
    
    ks = np.linalg.pinv(F)*np.matrix(meanFRs).T
    c0 = ks[0]
    pd = np.arctan2(ks[1],ks[2])
    c1 = ks[1]/np.sin(pd)
    
    c0 = np.asarray(c0)[0][0]
    c1 = np.asarray(c1)[0][0]
    pd = np.asarray(pd)[0][0]
    return [c0,c1,pd]

plt.figure(figsize=(7,5))

#====================================================#
# YOUR CODE HERE:
#   Fit the cosine tuning curve for electrode 17 and plot
#     1) the average firing rate for electrode 17 to each of the 8 directions and 
#     2) the fitted tuning curve.
#====================================================#
reach0 = np.zeros([1,0])
a = 0
reach1 = np.zeros([1,0])
b = 0
reach2 = np.zeros([1,0])
c = 0
reach3 =np.zeros([1,0])
d = 0
reach4 = np.zeros([1,0])
e = 0
reach5 = np.zeros([1,0])
f = 0
reach6 =np.zeros([1,0])
g = 0
reach7 = np.zeros([1,0])
h = 0
for i in range(R.shape[0]):
  target = R[i]['target'][0:2]
  if(target[0]==0 and target[1] == 120):
    reach0 = np.append(reach0,np.zeros([1,1]),axis = 1)
    reach0[0,a] = calculateFR(i)
    a = a + 1
  if(int(target[0]) == 84 and int(target[1]) == 84):
    reach1 = np.append(reach1,np.zeros([1,1]),axis = 1)
    reach1[0,b] = calculateFR(i)
    b = b + 1
  if(target[0] == 120 and target[1] == 0):
    reach2 = np.append(reach2,np.zeros([1,1]),axis = 1)
    reach2[0,c] =calculateFR(i)
    c = c + 1
  if(int(target[0]) == 84 and int(target[1]) == -84):
    reach3 = np.append(reach3,np.zeros([1,1]),axis = 1)
    reach3[0,d] = calculateFR(i)
    d = d + 1
  if(target[0] == 0 and target[1] == -120):
    reach4 = np.append(reach4,np.zeros([1,1]),axis = 1)
    reach4[0,e] = calculateFR(i)
    e = e + 1
  if(int(target[0]) == -84 and int(target[1]) == -84):
    reach5 = np.append(reach5,np.zeros([1,1]),axis = 1)
    reach5[0,f] = calculateFR(i)
    f = f + 1
  if(target[0] == -120 and target[1] == 0):
    reach6 = np.append(reach6,np.zeros([1,1]),axis = 1)
    reach6[0,g] = calculateFR(i)
    g = g + 1
  if(int(target[0]) == -84 and int(target[1]) == 84):
    reach7 = np.append(reach7,np.zeros([1,1]),axis = 1)
    reach7[0,h] = calculateFR(i)
    h = h + 1

reach0 = np.mean(reach0,axis = 1)
reach1 = np.mean(reach1,axis = 1)
reach2 = np.mean(reach2,axis = 1)
reach3 = np.mean(reach3,axis = 1)
reach4 = np.mean(reach4,axis = 1)
reach5 = np.mean(reach5,axis = 1)
reach6 = np.mean(reach6,axis = 1)
reach7 = np.mean(reach7,axis = 1)
meanFR = np.array([reach0,reach1,reach2,reach3,reach4,reach5,reach6,reach7])
thetas = np.array([np.pi/2,np.pi/4,0,-np.pi/4,-np.pi/2,-3*np.pi/4,np.pi,3*np.pi/4])
param = tuning(thetas,meanFR.T)
t = np.arange(360)
f = param[0] + param[1]*np.cos(t*np.pi/180 - param[2])
plt.plot(t,f)
#====================================================#
# END YOUR CODE
#====================================================#   

plt.xlabel('Reach angle')
plt.ylabel('Firing rate')
plt.xlim([0,360])
plt.show()

"""### (b) (4 points) Preferred direction and modulation depth

Calculate the tuning parameters for every electrode. Pick the top 30 electrodes having the largest values of $|c_1|$ (where $c_1$, from homework #2, is from the tuning curve expression $\theta_0$ such that $f(\theta)= c_0+c_1 cos(\theta-\theta_0)$. The larger $|c_1|$, the greater the "modulation depth" of the electrode.  This modulation depth is defined as the difference in firing rate between the preferred and anti-preferred directions. For each of these top 30 electrodes, plot the preferred direction in polar coordinates. The magnitude of each vector should be $|c_1|$. Do these top 30 neurons span the reaching space well?
"""

#====================================================#
# YOUR CODE HERE:
#   Generate a polar plot for the top 30 electrodes where 
#   the angle is the preferred direction of a neuron and 
#   its magnitude is |c1|.
#
#   Hint: call plt.polar(top_30_angles, top_30_c1, '*')
#====================================================#
c1_angles = np.zeros([96,2])
for j in range(96):
  reach0 = np.zeros([1,0])
  a = 0
  reach1 = np.zeros([1,0])
  b = 0
  reach2 = np.zeros([1,0])
  c = 0
  reach3 =np.zeros([1,0])
  d = 0
  reach4 = np.zeros([1,0])
  e = 0
  reach5 = np.zeros([1,0])
  f = 0
  reach6 =np.zeros([1,0])
  g = 0
  reach7 = np.zeros([1,0])
  h = 0
  for i in range(R.shape[0]):
    target = R[i]['target'][0:2]
    if(target[0]==0 and target[1] == 120):
      reach0 = np.append(reach0,np.zeros([1,1]),axis = 1)
      reach0[0,a] = calculateFR(i,j)
      a = a + 1
    if(int(target[0]) == 84 and int(target[1]) == 84):
      reach1 = np.append(reach1,np.zeros([1,1]),axis = 1)
      reach1[0,b] = calculateFR(i,j)
      b = b + 1
    if(target[0] == 120 and target[1] == 0):
      reach2 = np.append(reach2,np.zeros([1,1]),axis = 1)
      reach2[0,c] =calculateFR(i,j)
      c = c + 1
    if(int(target[0]) == 84 and int(target[1]) == -84):
      reach3 = np.append(reach3,np.zeros([1,1]),axis = 1)
      reach3[0,d] = calculateFR(i,j)
      d = d + 1
    if(target[0] == 0 and target[1] == -120):
      reach4 = np.append(reach4,np.zeros([1,1]),axis = 1)
      reach4[0,e] = calculateFR(i,j)
      e = e + 1
    if(int(target[0]) == -84 and int(target[1]) == -84):
      reach5 = np.append(reach5,np.zeros([1,1]),axis = 1)
      reach5[0,f] = calculateFR(i,j)
      f = f + 1
    if(target[0] == -120 and target[1] == 0):
      reach6 = np.append(reach6,np.zeros([1,1]),axis = 1)
      reach6[0,g] = calculateFR(i,j)
      g = g + 1
    if(int(target[0]) == -84 and int(target[1]) == 84):
      reach7 = np.append(reach7,np.zeros([1,1]),axis = 1)
      reach7[0,h] = calculateFR(i,j)
      h = h + 1

  reach0 = np.mean(reach0,axis = 1)
  reach1 = np.mean(reach1,axis = 1)
  reach2 = np.mean(reach2,axis = 1)
  reach3 = np.mean(reach3,axis = 1)
  reach4 = np.mean(reach4,axis = 1)
  reach5 = np.mean(reach5,axis = 1)
  reach6 = np.mean(reach6,axis = 1)
  reach7 = np.mean(reach7,axis = 1)
  meanFR = np.array([reach0,reach1,reach2,reach3,reach4,reach5,reach6,reach7])
  thetas = np.array([np.pi/2,np.pi/4,0,-np.pi/4,-np.pi/2,-3*np.pi/4,np.pi,3*np.pi/4])
  params = tuning(thetas,meanFR.T)
  c1_angles[j,:] = np.array([np.abs(params[1]),params[2]])

c1_angles = c1_angles[c1_angles[:,0].argsort()]
c1_angles = np.flipud(c1_angles)
c1_angles = c1_angles[0:30,:]
print(c1_angles)
plt.polar(c1_angles[:,1],c1_angles[:,0],'*')
#====================================================#
# END YOUR CODE
#====================================================#

"""Question:  Do these top 30 neurons span the reaching space well?

Answer: No

### (c) (4 points) Preparing kinematics for optimal linear estimator. [Code solution provided; please understand it and answer the question.]

Fit the preferred directions by building an optimal linear estimator. We’ll use the first 400 trials in the R-struct for training and reserve the last 106 trials for testing our decoder in part (g). Concatenate all the neural data, at 1 ms resolution <br>
(hint: use the command `Y = scipy.sparse.hstack(R[0:400]['spikeRaster'])`).

Next, bin the millisecond resolution neural data, Y (representing the concatenated millisecond activity across the 400 trials), by counting the spikes in non-overlapping 25 ms bins. (Hint: use the `nsp.bin` function we provided.) 

To be clear, each row, corresponding to one electrode of neural data, should be binned in non-overlapping 25 ms bins. Name this variable `Y_bin`. Append a row of 1’s at the bottom of `Y_bin` via:
`Y_bin= np.vstack((Y_bin,np.ones(np.size(Y_bin,1))))`
to allow a bias term to be fit. 

Similarly, calculate the corresponding hand velocities in 25 ms intervals by using a first order Euler approximation, i.e.,

$$v(t) = \frac{cursorPos[t+25] -cursorPos[t]}{0.025}$$
(Hint: Like the neural data, concatenate all the cursor positions, at 1 ms resolution, by using the command `X =scipy.sparse.hstack(R[0:train_num]['cursorPos'])`, then sample these velocities every 25 ms, and call the resultant matrix of velocities `X_bin`. Discard the last bin that does not have 25 ms worth of data.). 

Note that if you have done everything correctly, then `np.size(Y_bin, 1)` should equal `np.size(X_bin, 1)`. What are the dimensions of `Y_bin` and `X_bin`?

(Aside: If you observe the velocities, you’ll notice that they are not as smooth as they could be; this could be improved by using higher-order approximations to compute velocity – however, we wanted to keep the velocity calculation simple in this homework.)
"""

#====================================================#
# YOUR CODE HERE:
#   Bin the data.
#====================================================#
dt = 25
binnedR = np.empty((0,0),dtype = list)
train_num = 400
Y = scipy.sparse.hstack(R[0:train_num]['spikeRaster'])
X = scipy.sparse.hstack(R[0:train_num]['cursorPos'])
X = scipy.sparse.csc_matrix(X)
Y_bin = nsp.bin(Y, dt,'sum')
Y_bin = np.vstack((Y_bin, np.ones(np.size(Y_bin,1))))

X_bin = nsp.bin(X, dt,'first')
X_bin = np.diff(X_bin[0:2,:])/dt*1000
#====================================================#
# END YOUR CODE
#====================================================#

print("size of Y_bin:", Y_bin.shape)
print("size of X_bin:", X_bin.shape)

"""Question: What are the dimensions of `Y_bin` and `X_bin`?

Answer:

### (d) (6 points) Fitting the parameters in an OLE

Fit the optimal linear estimator that takes your spike counts binned at 25 ms resolution, `Y_bin`, and your sampled velocities every 25 ms, `X_bin`, and calculates the optimal linear decoder via:

$$ L = X_{bin} * Y_{bin}^{\dagger}$$
where $Y_{bin}^{\dagger}$ is the pseudo inverse of $Y_{bin}$, you can use `scipy.linalg.pinv` in python to calculate the pseudo inverse.<br>
Consider the top 30 electrodes in part (b). For each of these 30 electrodes, we want to visualize their preferred direction and modulation depth (like we did for the cosine fits of preferred direction). If electrode $i$ is one of these 30 electrodes, plot `L[:, i]` in polar coordinates. (Think about why we can think of `L[:,i]` as a preferred direction and magnitude.)  Does this plot look similar to the plot you derived in part (b)?
"""

#====================================================#
# YOUR CODE HERE:
#   Fit the OLE matrix L via least squares, and visualize
#   L[:,i] for the top 30 electrodes found in part (b) in
#   an analogous polar plot.
#====================================================#
pass
#====================================================#
# END YOUR CODE
#====================================================#

"""Question: Does this plot have better coverage of the entire workspace than the plot you derived in part (b)?

Abswer:

### (e) (6 points)

Using the matrix $L$ you derived in part (d), we will now decode new neural data. Using the last 106 trials, we’ll evaluate how good our optimal linear estimator is. We are going to operate trial by trial. For each trial in the R-struct, bin the neural data at 25 ms resolution. Remember to append a row of 1’s at the bottom of the neural data. Use the matrix $L$ to decode the neural activity and get decoded velocities for each trial. On the same plot, show the decoded trajectory for each trial. Use `R[i]['cursorPos'][0:2,0]` as the starting cursor position on trial $i$, and find position by integrating the decoded velocity. Do the trajectories appear normal, or are there idiosyncracies in the decoder?
"""

plt.figure(figsize=(7,7))
#====================================================#
# YOUR CODE HERE:
#   Decode data for the last 106 trials, and plot the 
#   decoded positions.  If pos is a 2 x T array holding
#   all the decoded positions, you may plot them via:
#
#     plt.plot(pos[0,:], pos[1,:], '.')
#
#====================================================#

pass
#====================================================#
# END YOUR CODE
#====================================================#

"""Question: Do the trajectories appear normal, or are there idiosyncracies in the decoder?

Answer:

### (f) (3 points)

For the decoder in part (e), what is the average mean-square error in position per trial? (For each time bin in a trial, calculate the squared Euclidean distance between the decoded position and the true hand position. Average all these squared Euclidean distance differences across all time in the trial. Finally, average across all trials.)
"""

#====================================================#
# YOUR CODE HERE:
#   Calculate the mean-squared error between the decoded
#   hand position and the true hand position.  Average
#   the squared errors across time; then average the squared
#   errors across trials.
#====================================================#
pass
#====================================================#
# END YOUR CODE
#====================================================#

"""Answer: """

